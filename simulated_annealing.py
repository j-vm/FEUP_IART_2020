import math
import random

from FEUP_IART_2020.objective import *
from FEUP_IART_2020.greedy import *


def simulated_annealing(photos):
    solution = generate_slides(photos) #generate slides, sorted by horizontal and then vertical
    score = ObjectiveFunction(solution)

    temp = 100000
    temp_min = 1
    cooling_rate = 0.85

    while temp > temp_min:
        new_solution = addMutation(solution)
        new_score = (-1 * ObjectiveFunction(new_solution))

        if new_score > score:
            solution = new_solution
            score = new_score
        else:
            accProbability = acceptanceProbability(score, new_score, temp)

            if accProbability > random.random():
                solution = new_solution
                score = new_score

        temp = temp*cooling_rate

    print(ObjectiveFunction(new_solution))
    return new_solution


def acceptanceProbability(score, new_score, temp):
    loss = abs(score-new_score)
    return math.exp(-(loss/temp))


def addMutation(slides):
    #For example, in the travelling salesman problem each state is typically defined as a
    # permutation of the cities to be visited, and its neighbours are the set of permutations
    # produced by reversing the order of any two successive cities.
    # A new solution is generated by inverting the "place" of two successive
    length = len(slides)-1

    idx1 = 0
    idx2 = 0

    while idx1 == idx2: #to make sure we pick different idx
        idx1 = random.randrange(0, length)
        idx2 = random.randrange(0, length)

    swapPositions(slides, idx1, idx2)
    swapPositions(slides, idx1, idx2)
    swapPositions(slides, idx1, idx2)
    swapPositions(slides, idx1, idx2)
    return slides


def swapPositions(slides, pos1, pos2):
    slides[pos1], slides[pos2] = slides[pos2], slides[pos1]
    return slides